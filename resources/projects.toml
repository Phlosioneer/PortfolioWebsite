
featured = [
	"penguin",
	"blue_lagoon",
	"lights_out",
	"bytecode_editor",
]

not_featured = [
	"portfolio",
	"tiled_map_loader",
	"zork",
	"covid_questionnaire",
	"jmaker",
	"connect_four",
	"pentago",
	"download_hawk",
	"color_picker",
	"gw2_tradingpost",
	"knights_dialer",
	"lua-rs",
	"pipelined_mips",
	"molek_solitaire",
	"sudoku_interactive",
	"calculator",
	"carcassonne"
]

[projects.penguin]
name = "Penguin"
language = "Java"
dates = [2012]
brief = "A Java based puzzle game about a sliding penguin"
image = "placeholder.png"
desc = """
**Penguin** was a small tile-based puzzle game I first made in my senior year of
high school to help with college admissions. It was based on the sliding ice puzzles
of Pokemon's ice caves. The player controlled a penguin that could walk over ground, 
and could slide over ice until it hit an object. The goal was to reach a door at the
end of the level. Solutions involved paths that crossed over themselves multiple
times.

The project was done using Processing, a thin wrapper language around Java. It
took approximately 20 hours to program and create assets. Unfortunately, the original 
copy has been lost over the years.
"""

[projects.covid_questionnaire]
name = "Covid Questionnaire"
language = "Javascript"
dates = [2020]
brief = "A Covid screening survey for an Orthodontist"
gitlab = "https://gitlab.com/Phlosioneer/covid-questions"

[projects.zork]
name = "Zork"
language = [ "C", "Rust" ]
brief = "Project to translate the classic text-based adventure game Zork into Rust"
image = "placeholder.png"
repo = "https://gitlab.com/Phlosioneer/zork-rs"
desc = """
**Zork** is a classic text-based adventure game, and this project
partially re-implemented it in Rust. The original C source for the game is
available on the internet, but it's poorly commented with minimal variable
names. The first goal of the project was to learn more about the C Foreign Function
Interface (FFI) by implementing some functions in Rust and then linking the
binaries together. The second goal of the project was to practice reverse
engineering algorithms and legacy code.

I made an effort to not just blindly translate the C into Rust for each
function. Instead, I figured out what the function was doing, its purpose in
the game, and refactored the code as I translated it.

An issue that appeared early on was the difficulty of testing changes. I
was able to make unit tests for individual Rust functions, but integration
tests were done by manually playing the game. That didn't even work very well;
sometimes replacing a function would cause bugs to appear in code I hadn't even
looked at yet. To address these issues, I created an integration testing program
that recorded manual inputs and the original program's output text. It then ran
the C and Rust hybrid binary and checked the output against its recordings. The
recordings were large, so I stored them in a [separate repository]
(https://gitlab.com/Phlosioneer/zork-playback). With proper integration testing
set up, I made good progress.

I stopped the project when I reached the command processing code. It was too
tangled in unwritten assumptions, indirection, and hacky algorithms for me to
rewrite.
"""

[projects.lights_out]
name = "Lights Out"
language = "Javascript"
brief = "Classic puzzle game as a web page"
repo = "https://github.com/Phlosioneer/react-lights-out/"
desc = """
**Lights Out** is a game that I created to practice making web pages using React.
It's a simple implementation of the classic handheld game Lights Out. The goal of
the game is to reach a fully lit-up board. Lighting up a square also lights its
adjacent and diagonal neighbors. It's a completed game, and can be played [right now.]
(https://phlosioneer.github.io/react-lights-out/)

I used this project to experiment with babel, JSX, and React add-on packages
for managing state. It was just complicated enough to be non-trivial to implement.
"""

[projects.connect_four]
name = "Connect Four"
language = "Several" # Languages will be listed in description
brief = "Same game, in several languages"
desc = """
**Connect Four** was a multi-language project. I implemented the game
Connect Four using standard text I/O in several languages. Similar to the
Rosetta Code project, the goal was to make the same thing in many languages to
see the differences between how the languages operate, and how large or small
each codebase was.
"""

[[projects.connect_four.screenshots]]
image = "ConnectFourC.png"
desc = """
This is from the C implementation of Connect Four, for Windows. It uses the
windows console API to switch the command prompt from OEM to Utf-8, checks that
the user's console font supports Utf-8, and then uses the Box Drawing characters
to draw the grid.

[Github Repo](https://github.com/Phlosioneer/ConnectFourC)
"""
# F09B is the Font Awesome code for github.

[projects.portfolio]
name = "Portfolio Website"
language = "Javascript"
brief = "This website! Made from scratch without frameworks and hosted on Github"
repo = "https://github.com/Phlosioneer/PortfolioWebsite"
desc = """
**My Portfolio** is this website that you're viewing right now. I
created it from scratch in November and December of 2020, during the COVID-19
pandemic. This website uses configuration files to describe each of my programming
projects, and a Node script to generate the static website from those config files.
I use the templating language Mustache for splitting HTML into composable pieces,
and I use ExpressJS for localhost development.

A makefile manages the generator script and SCSS to CSS conversion. I decided
to use Make for build management instead of Yeoman, Gulp, or others because of
familiarity and simplicity.

One early goal for the project was to minimize the dependencies, and provide an
extremely light-weight site. I decided to avoid React and other similar frameworks,
and use Bulma and plain HTML for visual effects. Bulma is a pure css library, making
it very lightweight. I also decided to avoid JQuery, preferring built-in operations
instead; and there are no polyfills, to keep the Javascript minimal.
"""

[[projects.portfolio.screenshots]]
image = "PortfolioEarlyDev.png"
desc = """
An early mockup of the portfolio website.
"""

[projects.blue_lagoon]
name = "Blue Lagoon"
language = "Processing"
brief = "Digital implementation of the four player board game Blue Lagoon"
repo = "https://github.com/Phlosioneer/BlueLagoon"
desc = """
**Blue Lagoon** was an attempt to build a digital version of the Blue Lagoon
board game. During this project I experimented with using Tiled's map file format
to handle UI elements and store all the game's data. I made a lot of progress with
the assets and map file, but the project stalled while writing the code for the game.
Using the map file for UI elements was not sustainable. The map file also just had
too much data; the functions to parse the single file were getting unwieldy.

To make more progress on the project, I would have to redo a lot of parsing code,
split the game data into smaller files, and rewrite the UI. I decided to drop the
project instead.

As part of this project, I used my [TiledMapLoader](tiled_map_loader) library.
"""

[[projects.blue_lagoon.screenshots]]
image = "BlueLagoonMain.png"
desc = """
This is what the board looks like in-game. All of the various indicators on the top
and left of the screen work, but have nothing to display. The board is made of hex
tiles that highlight when the mouse is over them.
"""

[[projects.blue_lagoon.screenshots]]
image = "BlueLagoonMenus.png"
desc = """
These are some of the overlays. Each scoring category has a tooltip-like window to
explain the game mechanics of the scoring.
"""

[projects.jmaker]
name = "JMaker"
language = "Java"
brief = "Build system hybrid between Make and Gradle for Java projects with complex dependencies"
repo = "https://github.com/Phlosioneer/JMaker"
desc = """
**JMaker** was born from frustration with using Gradle for managing Java
projects with nonstandard setups. Gradle's design prioritizes sane defaults, and
build files should only need to describe deviations from the default project
structure. This philosophy works excellently for pure Java projects, but runs into
problems if the project mixes in other languages or dynamically generated resources.
It also has a hard time running arbitrary code as part of its build files. Although
it uses a programming language to define them, it only exposes an extremely small,
minimal API. Each plugin has an API, but the details are often undocumented. Finally,
it can have difficulties building an accurate dependency graph for unusual project
setups.

GNU Make has the opposite philosophy; it offers some defaults, but assumes very
little about how it's being used. Make excels at managing complex build processes
by using very robust bash integration and a well-defined dependency graph. However,
makefiles are described using a very old language with strange corner cases and limitations.
Notably, it has extreme difficulties handling commands, variable values, and bash commands
that include colons. The Java command-line compiler (javac) makes use of colons in
many of its commands, so Make has a hard time with Java.

JMaker was an effort to make a tool that could leverage the strengths of each,
with fewer downsides. It used Lua to define its configuration and commands, and uses
a rule-based production system like Make. That would allow it to have a clear and
well-defined dependency graph, with all the power of using an actual programming
language for build files.

I finished a fully functioning Lua parser and interpreter with custom syntax for recipe
definition. But work on the project stalled when writing the code to handle external
scripts. I learned how difficult it is to correctly start processes, capture their input
and output, manage environment variables, and handle crashed or unresponsive commands.
Make has built up a very robust system for calling executables and running bash scripts
that is extremely difficult to port to Java. It handles many corner-cases and works around
issues that I didn't even know existed until I tried to implement a similar system.

I started JMaker as part of my [Blue Lagoon](blue_lagoon) project. Gradle wasn't
able to understand some asset-generating scripts for tileset management. Unfortunately,
I wasn't able to get it working well enough to replace Gradle on that project.
"""

[projects.pentago]
name = "Pentago"
language = "Java" # TODO: Processing?
brief = "Digital form of the board game"

[projects.download_hawk]
name = "Download Hawk"
language = "Java"
brief = "Program to delete unused downloaded files"

[projects.color_picker]
name = "Pixel Art Color Picker"
language = "Processing"
repo = "https://github.com/Phlosioneer/ColorPicker"
brief = "Helper program for the math of pixel art coloring"
desc = """
This is a tool I made to help make palettes for pixel art. It uses
the formulas provided by a prominent pixel art tutorial series,
[PixelBlog](https://www.slynyrd.com/blog/2018/1/10/pixelblog-1-color-palettes).
All the parameters are configurable, including editable quadratic
bezier curves. It allows saving and loading palette configuration as
a JSON file, and can export them to .pal files that most image editing software can
understand.

The tool was made using Processing, without using external GUI libraries.
"""

[projects.gw2_tradingpost]
name = "Guild Wars 2 Trading Post Analyzer"
language = "Jupyter Notebook"
brief = "Notebook to find and exploit trades on an MMO"
desc = """
This notebook used public APIs to find profitable trades.
It searched for any items worth more than the sum of their parts,
after accounting for buying and selling tax.
"""

[projects.bytecode_editor]
name = "Python JVM Bytecode Editing Library"
language = "Python"
brief = "Script to parse and modify Java bytecode files"
desc = """
Over the years, I've wanted to tweak Minecraft Mods slightly for
balance adjustments and custom behaviors. At first, I only wanted
to change a few static constants, but my requirements evolved over
time to include new behaviors and even rewriting some functions. In
the process of making python scripts and Jupyter Notebooks to patch
these files, I slowly built a bytecode editing library to make the
task simpler. I finally reached the point where it made more sense
to make a fully-featured library than repeated ad-hoc solutions.

There are no other python libraries for automatically manipulating
JVM files, so I combined all the knowledge I had accumulated into one
library and command-line utility. The basics were mostly done - parsing,
simple modifications, and repackaging the edited class files into a jar.
I created a patching system that used regex to decide which files to pull
out of a jar and which patches to apply to those files. I made a backup
system to save copies of the clean jar file before patching, and a command
to restore the backup if the patches went wrong.

The difficult part was stack frame analysis. Each Java method contains a
table of stack frames, which are used to typecheck the bytecode. Unlike
the rest of the class file format, the stack map table and stack frames are
very poorly documented. Many details are only specified in terms of a
Prolog verification program, which I had to reverse engineer to reveal the
specified behavior. Adding to the difficulty, stack frames are encoded in
an extremely strange, highly compressed format, with several special-cased
behaviors.

Even once the stack frames were parsed and re-serialized correctly, it
was very difficult to expose them to patch code in a convenient way. The
placement of the stack frames roughly follows a Basic Block breakdown of
the assembly code: each instruction that is a target of a branch must have
a stack frame entry. Frames are also needed whenever a new local variable is
defined, and local variables are stored in a stack format, so defining a new
local variable is not a simple process. The new local variable needs to be
put into a scope as defined by its placement in the local variable stack.

One extra challenge imposed by my testing suite was that the class file had
to be generated in the same way as the original compiler did. This is because
parsing the file into a convenient representation still needed to be serialized
exactly the same as it was originally. That meant I couldn't take shortcuts
with bytecode instruction generation; there are many short instructions for
encoding common constants, common local variables, and common stack manipulations.
So for example, parsing the bytecode turned "fconst_1" into a python float 1.0;
but serializing the bytecode, instead of the more general "ldc" opcode for
loading constants, the bytecode had to be serialized back into "fconst_1".
In this instance that is a simple check, however there are 20 special constant
opcodes, 40 special local variable loading and storing opcodes, 5 special
branches for comparing with zero, 4 variants of each arithmetic opcode, 5
variants of each array manipulation opcode, 3 different ways to create an
array, etc. The JVM's bytecode has a lot of redundancy that needs to be removed
for patches, and re-applied for serializing.

The library is currently being used by a patching harness based around
Minecraft's folder structure and the particular goal of mod adjustment.
However, the library was designed to stand on its own merits and is not
specific to Minecraft in any way.
"""

[projects.knights_dialer]
name = "Knight's Dialer Puzzle"
language = "Jupyter Notebook" # TODO: Just python?
brief = "Solves the Knight's Dialer puzzle"

[projects.lua-rs]
name = "Lua Interpreter"
language = "Rust"
repo = "https://gitlab.com/Phlosioneer/lua-rs"
brief = "A Lua script interpreter in pure Rust"
desc = """
**Lua-rs** was a Lua interpreter implemented in rust. The library is able
to parse Lua code into an abstract syntax tree. I started on this project
because there were no pure Rust crates able to run Lua. The only option was
to use a wrapper around the Lua C API, which was not very safe.

Going into this project, I had a lot of experience with Lua: my
[JMaker](jmaker) project involved writing an interpreter for an extended
version of Lua. However, I eventually lost the motivation to continue with
the project. It used a recursive-descent parser, which I was unable to make
safe in Rust. It also used a recursive expression evaluator, which was unsafe
due to possible stack overflows. At the time I didn't know there were
alternatives to recursive descent, and also got bogged down in the details of
memory management in the AST-walking code.

With my current knowledge of parsers and a better understanding of managing
complex algorithms, I think I would be able to complete this project. However
there are now multiple Rust crates available to parse and execute Lua safely.
"""
#TODO: Was lua-rs before or after JMaker?
#TODO: How complete is lua-rs? Does it work?

[projects.pipelined_mips]
name = "Pipelined MIPS CPU"
language = "Verilog"
brief = "A fully functional 32-bit MIPS CPU core"
repo = "https://github.com/Phlosioneer/pipelined-mips"
desc = """
**Pipelined MIPS** is a fully pipelined 32-bit [MIPS]
(https://en.wikipedia.org/wiki/MIPS_architecture) CPU made as a
final project of a systems engineering class at Bucknell. The CPU is described
by Verilog code using a reduced subset of Verilog, to enforce a logic-gate
level understanding of the CPU. A team of three students and I designed and
implemented the CPU over two months. It is able to run simple MIPS assembly
programs. 

The project was a success and was submitted in October of 2017. I
continued working on it for another month after submission, to clean
up the project and fix known bugs. I also added support for more
opcodes, and added more tests.
"""
#TODO: What software did we use to simulate it?

[projects.molek_solitaire]
name = "Solver for Molek-Syntez Solitaire"
language = "Rust"
brief = "Solver for a very hard solitaire game from Zachtronics"
repo = "todo"
image = "placeholder.png" #TODO: in-game solitaire cards showing normal and glitched cards.
desc = """
Zachtronics is a game studio known for making games about programming.
However, another thing they're known for is solitaire. Each of their
programming games contains a custom-made solitaire minigame thematically
similar to the programming game. The solitaire minigames range from
moderately difficult to nearly impossible, and they don't avoid generating
unsolvable games. While playing the solitaire for one of their games
(Molek Syntez), I had a feeling that there was an algorithm to solve it.
This project is my attempt to implement that algorithm.
"""
#TODO: How far did I get?

#TODO: Document the math/diagrams/algorithm in the repo. I think I still
#have my drawings for it.

#TODO: Use screenshots below to feature those drawings and the algorithm.

[projects.sudoku_interactive]
name = "Interactive Sudoku"
language = "Javascript"
brief = "A Sudoku game that teaches the player advanced techniques"
repo = "TODO"
desc = """
**Interactive Sudoku** is an app that helps players improve their Sudoku
skills. While there are many Sudoku apps out there, and many solvers as well,
this app is different. The app notices the techniques that the player is
using to solve puzzles, and how often the player is able to notice those
moves, and saves those as a profile of the player. The app then uses that
profile to provide targeted hints, and to generate puzzles that teach the
player new skills.

This project is a work in progress, and there are technical challenges
that I haven't resolved yet. I have basic Sudoku entering and playing
functionality, and I have a list of techniques to implement as part of the
skill recognition system. The rest has not been implemented yet.
"""

[projects.calculator]
name = "Terminal Calculator"
language = "Rust"
brief = "A simple infix calculator"
desc = """
This project was a simple calculator for learning and practicing input
parsing.
"""

[projects.carcassonne]
name = "Carcassonne"
language = "Java"
brief = "Digital form of the board game"
repo = "https://gitlab.com/Phlosioneer/Carcassonne"
desc = """
**Carcassonne** was a digital implementation of the classic boardgame
Carcassonne. The game uses tiles to slowly build up a board, and scores
points based on the geometry of that board. It was a very interesting
challenge to calculate the connections and shapes of the boards, and
properly draw outlines of those shapes. I was able to successfully overcome
that challenge, but lost interest in the project afterwards.
"""

[projects.tiled_map_loader]
name = "TiledMapLoader Library"
language = "Java"
brief = "Java library to read TMX and TSX files"
repo = "https://github.com/Phlosioneer/TiledMapLoader"
desc = """
**TiledMapLoader** is a library for parsing [Tiled's TMX/TSX file format]
(https://www.mapeditor.org/). It is used my several of my other game projects,
including [Blue Lagoon](blue_lagoon) and [Pentago](pentago). It's with Java 8
compliance, because I used it in some of my Processing projects and Processing only
supports Java 8.
"""
